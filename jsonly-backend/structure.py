from google import genai
from google.genai import types
from pathlib import Path
import os
import json
from dotenv import load_dotenv
import logging
import asyncio
from datamodel_code_generator import InputFileType, generate, DataModelType
from tempfile import NamedTemporaryFile
import importlib
import importlib.util
import sys
from textwrap import dedent
from typing import TypedDict


class ExtractOutput(TypedDict):
    template: dict
    summary: dict


logger = logging.getLogger(__name__)

load_dotenv()

client = genai.Client(api_key=os.environ['GEMINI_API_KEY'])

async def call_gemini_with_retries(
    client: genai.Client,
    *,
    model: str,
    contents: list,
    max_retries: int = 5,
    initial_delay: float = 4.0,
    config=None
):
    delay = initial_delay
    for attempt in range(1, max_retries + 1):
        try:
            return await client.aio.models.generate_content(
                model=model,
                contents=contents,
                config=config
            )
        except Exception as e:
            if e.code == 503 and attempt < max_retries:
                # adding jitter seems to increase success rate
                wait = delay 
                logger.warning(
                    f"Gemini overloaded (attempt {attempt}/{max_retries}); "
                    f"retrying in {wait:.1f}s..."
                )
                await asyncio.sleep(wait)
                delay *= 2
                continue
            raise


async def ai_generate_template(filepath) -> str:
    '''
    Returns: a JSON structure (template) for the file
    '''
    generate_template_prompt = dedent(
        """
        You will be asked to understand a document and summarize its structure using a JSON schema.
        The schema should include all important fields, their type and a description.
        Do NOT add examples.
        Do NOT use date type for dates (use strings).
        You can used nested fields (nested dicts, lists) when appropriate.
        Your output should be a valid JSON schema representation.
        """
    )

    response = await call_gemini_with_retries(
        client=client,
        model="gemini-2.0-flash",
        contents=[
            types.Part.from_bytes(
                data=Path(filepath).read_bytes(),
                mime_type='application/pdf',
            ),
            generate_template_prompt
        ]
    )

    clean_text = response.text.replace("```json", "").replace("```", "")
    data = json.loads(clean_text)
    # Sort keys alphabetically
    sorted_data = {key: data[key] for key in sorted(data)}
    return json.dumps(sorted_data, indent=2)


async def ai_extract_with_model(filepath:str, model_class) -> dict:
    '''
    This function will be called internally by function: ai_extract
    '''

    extract_prompt = dedent(
        """
        You will be asked to understand a document and summarize its structure.
        Your output should be a valid JSON schema representation.
        """
    )

    response = await call_gemini_with_retries(
        client=client,
        model="gemini-2.0-flash",
        contents=[
            types.Part.from_bytes(
                data=Path(filepath).read_bytes(),
                mime_type='application/pdf',
            ),
            extract_prompt
        ],
        config={
            "response_mime_type": "application/json",
            "response_schema": model_class,
        }
    )

    return json.loads(response.text)


async def ai_extract(filepath:str, template:str|None) -> ExtractOutput:
    '''
    Args:
        filepath: path to PDF file
        template: template to use; if not provided, will be generated by AI
    '''
    if template is None:
        template = await ai_generate_template(filepath)

    with NamedTemporaryFile(mode='a+', suffix='.py', delete=True, delete_on_close=False) as tmp:
        generate(
            template,
            input_file_type=InputFileType.JsonSchema,
            output=Path(tmp.name),
            output_model_type=DataModelType.PydanticV2BaseModel,
        )

        module_name = Path(tmp.name).stem
        spec = importlib.util.spec_from_file_location(module_name, tmp.name)
        module = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = module  # optional: register it in sys.modules
        spec.loader.exec_module(module)

        Model = getattr(module, "Model")

        response = await ai_extract_with_model(filepath, Model)
        return {
            'summary': response,
            'template': json.loads(template)
        }


async def ai_harmonize_templates(list_of_dicts):
    harmonize_prompt = dedent(
        """
        You are given a list of JSON templates (as Python dicts). Your task is to analyze them and return a single "harmonized" template (as a JSON/dict) that captures the common structure and information across all the input templates.
        - Merge fields that are semantically equivalent, even if their key names differ (e.g., "address" and "location" or "phone" and "phone_number").
        - Use your judgment to choose the most representative or standard key name for merged fields.
        - Include keys and nested structures that are conceptually present in most or all templates, even if not every template uses the exact same key.
        - If a field is present in some templates but not others, include it if it represents important shared information.
        - Your output must be a valid JSON/dict.
        - Do not include any explanation or extra text, only the harmonized JSON.
        - For the values of the field, pick any representative one from the provided templates.
        """
    )
    # Prepare the input for Gemini: a string with all JSONs, pretty-printed
    jsons_str = "\n\n".join([json.dumps(d, indent=2) for d in list_of_dicts])
    full_prompt = (
        harmonize_prompt
        + "\n\nHere are the input templates:\n"
        + jsons_str
    )
    response = await call_gemini_with_retries(
        client=client,
        model="gemini-2.0-flash",
        contents=[full_prompt]
    )
    
    clean_text = response.text.replace("```json", "").replace("```", "")
    return json.loads(clean_text)
